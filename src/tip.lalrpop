use std::str::FromStr;
use crate::frontend::*;
use crate::loc;

grammar;

match {
  "+",
  "-",
  "*",
  "/",
  "(",
  ")",
  ".",
  "&",
  "{",
  "}",
  ";",
  ",",
  "=",
  "==",
  ">",
  ":",
  "var",
  "if",
  "while",
  "output",
  "input",
  "return",
  "else",
  "alloc",
  "null",
  r"[a-zA-Z][a-zA-z_0-9]*",
  r"[0-9]+",

  r"//[^\n\r]*[\n\r]*" => { },
  r"\s*" => { },
}

Identifier: Indentifier = {
    r"[a-zA-Z][a-zA-z_0-9]*" => Indentifier::new(<>.to_owned()),
}

pub Tip: Ast = {
  <FuncList> => Ast::new(<>),
}

FuncList: Vec<Box<Statement>> = {
  <Function> => vec![<>],
  <FuncList> <Function> => append(<>),
}

pub Function: Box<Statement> = {
  <st: @R> <i:Identifier> "(" <a:ArgList?> ")" "{" <l:LocalDecls*> <c:CompoundStatement?> <r:ReturnStatement> "}" <ed: @L> =>
     Box::new(Statement { kind: StatementKind::Function(Function::new(i, a, l, c, r)), loc: loc!(st, ed) } ),
}

LocalDecls: Vec<TypedIndentifier> = {
   "var" <ArgList> ";" => <>
}

ArgList : Vec<TypedIndentifier> = {
  <Identifier> => vec![TypedIndentifier::new_untyped(<>)],
  <s:ArgList> "," <i:Identifier> => append(s, TypedIndentifier::new_untyped(i)),
}

pub Statement: Box<Statement> = {
   <Stmt> => Box::new(<>),
}

Stmt: Statement = {
   <st: @R> <l:Expression> "=" <r:Expression> <ed: @L> ";" => 
     Statement { kind: StatementKind::Assign(Box::new(Assign { lhs: l, rhs: r })), loc: loc!(st, ed) },

   <st: @R> "output" <ex:Expression> ";" <ed: @L> => Statement { kind: StatementKind::Output(ex), loc: loc!(st, ed) },

   <st: @R> "if" "(" <g:Expression> ")" "{" <t:CompoundStatement> "}" <e:Else?> <ed: @L> => 
      Statement { kind:  StatementKind::If(Box::new(If { guard: g, then: t, elsee: e })), loc: loc!(st, ed) },

   <st: @R> "while" "(" <e:Expression> ")" "{" <b:CompoundStatement> "}" <ed: @L> =>
      Statement { kind: StatementKind::While(While { guard: e, body: b } ), loc: loc!(st, ed) }
}

ReturnStatement: Box<Statement> = {
   <st: @R> "return" <ex:Expression> ";" <ed: @L> => 
      Box::new(Statement { kind:  StatementKind::Return(ex), loc: loc!(st, ed) })
}

Else: Box<Statement> = {
   "else" "{" <CompoundStatement> "}" => <>,
}

CompoundStatement: Box<Statement> = {
   <st: @L> <cc:CompoundStatementBody> <ed: @R> => Box::new( Statement { kind:  StatementKind::Compound(cc), loc: loc!(st, ed) } ),
}

CompoundStatementBody: Vec<Box<Statement>> = {
   <Statement> => vec![<>],
   <CompoundStatementBody> <Statement> => append(<>),
}

pub Expression: Box<Expression> = {
    <Expr> => Box::new(<>),
}

Expr: Expression = {
    #[precedence(level="0")]
    Atom,

    #[precedence(level="1")] #[assoc(side="right")]
    "*" <Expr> => Expression::Unary(Box::new(Unary::Deref(Box::new(<>)))),

    #[precedence(level="2")] #[assoc(side="right")]
    "&" <Identifier> => Expression::Unary(Box::new(Unary::Addressof(<>))),
    <e:Expr> "." <i:Identifier> => Expression::Member(Box::new(e), i),

    #[precedence(level="3")] #[assoc(side="left")]
    <e:Expr> "(" <l:CallList> ")" => Expression::Call(Box::new(Call { call: Box::new(e), args: l })),

    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expr> <o:CompareOp> <r:Expr> => Expression::Binary(Binary::new(Box::new(l), o, Box::new(r))),

    #[precedence(level="5")] #[assoc(side="left")]
    <l:Expr> <o:FactorOp> <r:Expr> => Expression::Binary(Binary::new(Box::new(l), o, Box::new(r))),

    #[precedence(level="6")] #[assoc(side="left")]
    <l:Expr> <o:ExprOp> <r:Expr> => Expression::Binary(Binary::new(Box::new(l), o, Box::new(r))),

    #[precedence(level="7")]
    "alloc" <Expr> => Expression::Alloc(Box::new(<>)),
    "input" => Expression::Input,
}

RecordList: Vec<Record> = {
  <Record> => vec![<>],
  <RecordList> "," <Record> => append(<>),
}

Record: Record = {
  <Identifier> ":" <Expression> => Record::new(<>),
}

CallList: Vec<Box<Expression>> = {
  <Expression> => vec![<>],
  <CallList> "," <Expression> => append(<>),
}

CompareOp: BinaryOp = {
   ">" => BinaryOp::Gt,
   "==" => BinaryOp::Eq,
}

ExprOp : BinaryOp = {
   "+" => BinaryOp::Plus,
   "-" => BinaryOp::Minus,
}

FactorOp : BinaryOp = {
   "*" => BinaryOp::Mul,
   "/" => BinaryOp::Div,
}

Atom: Expression = {
    <Identifier> => Expression::Indentifier(<>),
    <Num> => Expression::Number(<>),
    "+" <Num> => Expression::Number(<>),
    "-" <Num> => Expression::Number(<>),
    "(" <Expr> ")" => <>,
    "null" => Expression::Null,
    "{" <RecordList> "}" => Expression::Record(<>),
}

Num: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap()
}
